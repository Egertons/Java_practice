public class demo
{
	public static void main(String[] args)
	{
		int[] arr = new int[3];//一维数组
		int[][] tr = new int[3][4];
		/*
		定义了一个名称为tr的二维数组，其中包含着3个一维数组
		每个一维数组中有着4个元素。
		*/
		/*
		赋值操作中的2指的是tr这个二维数组中的第3个一维数组
		3指的是该一维数组中的第4位元素。	
		*/
		tr[2][3]=99;
		System.out.println("\n\t"+tr[2][3]);
		
		//二维数组的第二种定义方式：
		int[][] jjj = new int[3][]; //只指定二维数组中一维数组的长度
		
		//打印jjj 的话返回的是一维数组堆内存地址值。
		//假若这时打印jjj[0]的话，结果为null，因为并未赋值。
		System.out.println(jjj[0]);
		jjj[0] = new int[9];
		
		//打印二维数组中第一个一维数组的长度。
		System.out.println(jjj[0].length);
	}
}
/*
int[][] hhh = new int[3][];
假若这样定义二维数组的话；
其实在堆内存中是要开辟三个新的一维数组的但是因为并没有赋值
与此同时，数组是引用数据类型，引用数据类型的默认初始值是null。
对于这种定义方法 是可以在后续重新定义初始化值的。
Eg：hhh[0] = new int[9];       //两种做法都可以。
		hhh[0] = {2,3,4,55,667,76,555};    //以一个大数组中的元素作为一个新数组的被赋值项进行赋值操作。


需要注意的是，首次定义二维数组时没有去定义其中的一维数组的内容的情况下
在后续的操作步骤中，重新定义其中的一维数组值后，
其在堆内存中的关系是引用关系，并不是包含关系。
*/


//上面那个类写得太满了，换个类继续。
class xin
{
	public static void main(String[] args)
	{
		//二维数组的第二种静态定义方法（即定义初始值）
		int[][] yu = {{44,87,1,87},{88,9},{6,98},{5},{44,98},{12,14,16},{98}};  //***
		System.out.println(yu[0][1]);
	}
}
class  ceshi
{
	public static void main(String[] args)
	{
		int[] x,y[]; 
		//这种定义方法等同于
		//int[] x;    一维
		//int[] y[];  二维
	}
}
/*
对于二维数组在现实中的需求的解释：
当两个数组中的元素在意义上有着实际联系，本来就从属着层次关系。
这时秉承着数据类聚分析的思想，可以使用二维数组。
*/



/*
for()
{
	for()
	{
			//该格式为for嵌套
	}
}
*/
